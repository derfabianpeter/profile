stages:
  - version
  - build
  - release
  - push
  - deploy

variables:
  DOCKER_DRIVER: overlay2
  DOCKER_TLS_CERTDIR: ""

.ssh: &ssh
  - eval $(ssh-agent -s)
  - ssh-add <(echo "$SSH_PRIVATE_KEY")
  - mkdir -p ~/.ssh
  #- echo "$GITLAB_SSH_HOSTKEYS" > ~/.ssh/known_hosts
  - ssh-keyscan -H ${DEPLOYMENT_TARGET} > ~/.ssh/known_hosts

.deployment: &deployment |
  # Setup SSH deploy keys
  which ssh-agent || ( apk add --no-cache openssh-client )
  eval $(ssh-agent -s)
  ##
  ## Add the SSH key stored in SSH_PRIVATE_KEY variable to the agent store
  ## We're using tr to fix line endings which makes ed25519 keys work
  ## without extra base64 encoding.
  ## https://gitlab.com/gitlab-examples/ssh-private-key/issues/1#note_48526556
  ##
  echo "${SSH_PRIVATE_KEY}" | tr -d '\r' | ssh-add - > /dev/null 2>&1
  mkdir -p ~/.ssh
  chmod 700 ~/.ssh
  echo -e "Host *\n\tStrictHostKeyChecking no\n\n" > ~/.ssh/config 
  ssh-keyscan -H ${DEPLOYMENT_TARGET} >> ~/.ssh/known_hosts
  

version:
  stage: version
  image: registry.gitlab.com/juhani/go-semrel-gitlab:v0.21.1
  script:
    - release test-git || true
    - release test-api
    - release next-version --allow-current
    - release next-version --allow-current > .next-version
    - echo "RELEASE_URL=https://gitlab.com/api/v4/projects/$CI_PROJECT_ID/jobs/$CI_JOB_ID/artifacts/release" > build_info
    - echo "RELEASE_DESC=\"$(uname -mo) binary\"" >> build_info
    - echo "RELEASE_SHA=$CI_COMMIT_SHA" >> build_info
    - echo "RELEASE_VERSION=$(<.next-version)" >> build_info
  artifacts:
    paths:
    - build_info
    - .next-version
  except:
    - tags

Build:
  stage: build
  services:
  - docker:19.03.2-dind
  # remember to use specific version in your build images
  # see https://blog.callr.tech/building-docker-images-with-gitlab-ci-best-practices/
  image: docker:19.03.5-git 
  only:
    - master
  # fetching submodules here because usually themes are git submodules
  # see also the commented variables below
  before_script:
    - git submodule sync --recursive
    - git submodule update --init --recursive
    - echo -n $CI_JOB_TOKEN | docker login -u gitlab-ci-token --password-stdin $CI_REGISTRY
  script:
    - docker pull $CI_REGISTRY_IMAGE:latest || true
    - docker build --cache-from $CI_REGISTRY_IMAGE:latest -t $CI_REGISTRY_IMAGE:$CI_COMMIT_SHA .
    - docker push $CI_REGISTRY_IMAGE:$CI_COMMIT_SHA

# Release new Version
Release:
  stage: release
  image: registry.gitlab.com/juhani/go-semrel-gitlab:v0.21.1
  script:
    - rm -f release_info
    - mv build_info release_info
    - . release_info
    - release -v
    - release changelog
    - release commit-and-tag CHANGELOG.md release_info
  only:
    - master

Push latest:
  image: docker:19.03.5-git
  variables:
    # We are just playing with Docker here. 
    # We do not need GitLab to clone the source code.
    GIT_STRATEGY: none
  stage: push
  before_script:
  # docker login asks for the password to be passed through stdin for security
  # we use $CI_JOB_TOKEN here which is a special token provided by GitLab
  - echo -n $CI_JOB_TOKEN | docker login -u gitlab-ci-token --password-stdin $CI_REGISTRY
  only:
    # Only "master" should be tagged "latest"
    - master
  script:
    # Because we have no guarantee that this job will be picked up by the same runner 
    # that built the image in the previous step, we pull it again locally
    - docker pull $CI_REGISTRY_IMAGE:$CI_COMMIT_SHA
    # Then we tag it "latest"
    - docker tag $CI_REGISTRY_IMAGE:$CI_COMMIT_SHA $CI_REGISTRY_IMAGE:latest
    # Annnd we push it.
    - docker push $CI_REGISTRY_IMAGE:latest

# Finally, the goal here is to Docker tag any Git tag
# GitLab will start a new pipeline everytime a Git tag is created, which is pretty awesome
Push tag:
  image: docker:19.03.5-git
  variables:
    # Again, we do not need the source code here. Just playing with Docker.
    GIT_STRATEGY: none
  stage: push
  before_script:
  # docker login asks for the password to be passed through stdin for security
  # we use $CI_JOB_TOKEN here which is a special token provided by GitLab
  - echo -n $CI_JOB_TOKEN | docker login -u gitlab-ci-token --password-stdin $CI_REGISTRY
  only:
    # We want this job to be run on tags only.
    - tags
  script:
    - docker pull $CI_REGISTRY_IMAGE:$CI_COMMIT_SHA
    - docker tag $CI_REGISTRY_IMAGE:$CI_COMMIT_SHA $CI_REGISTRY_IMAGE:$CI_COMMIT_REF_NAME
    - docker push $CI_REGISTRY_IMAGE:$CI_COMMIT_REF_NAME

Deploy:
  stage: deploy
  image: tiangolo/docker-with-compose
  script: 
   - *deployment
   - DOCKER_HOST=ssh://${DEPLOYMENT_TARGET} docker-compose -f ci/docker-compose.yml -p peter-www up --remove-orphans -d
  allow_failure: false
  # deploying master only
  only:
    - master
  environment:
    name: production
  # # we tag specific runners here in our platform
  # tags:
  #   - deployment